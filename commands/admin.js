/* eslint-disable no-trailing-spaces */
/* eslint-disable indent */
/* eslint-disable no-unused-vars */
const { SlashCommandBuilder } = require('@discordjs/builders');
const { ShardClientUtil } = require('discord.js');
const bEmbeds = require("../assets/bEmbeds.js");
const { MessageEmbed, MessageActionRow, MessageButton } = require("discord.js");
const { Guilds } = require("../mongo/mongo.js");

module.exports = {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('for server owner + those with role from /admin setAdminRole')
        .setDefaultPermission(false)
        .addSubcommand(subcommand =>
            subcommand
                .setName("listcmds")
                .setDescription("(for testing purposes) output list of command objects into console"),
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName("buildchannels")
                .setDescription("Build/rebuild inhouse sixmans categories. Renders any old categories unusable."),
        ),

    execute,
};

async function execute(interaction)
{

    switch (interaction.options.getSubcommand())
    {

        case "listcmds":
        {
            const b = await interaction.guild.commands.fetch();

            const h = b.map((cmd) => `${cmd.name} ::: ID: ${cmd.id}`);

            console.log(h);

            return interaction.reply({ content: `\`\`\`${JSON.stringify(h, null, "\n")} \`\`\` ` });
        }

        case 'buildchannels': 
        {

            // verify that command caller has administrator permissions
            if (!interaction.member.roles.cache.some(role => role.name === "jahzoAdmin"))
            {
                return await interaction.reply("You need the jahzoAdmin role to use this command (can help prevent channel creation spam)");
            }

            const newInHouseCategory = await interaction.guild.channels.create('inhouse', { type: 'GUILD_CATEGORY', reason: "rebuilding inhouse channels via command" });

            // returns object containing all inhouse (IH) channel IDs
            // also moves any prior game-log to new IH category if it exists
            const getGameChannels = async (newIHcat) =>
            {
                const qvc = await newIHcat.createChannel("Q", { type: 'GUILD_VOICE' });
                const t1vc = await newIHcat.createChannel("Team 1", { type: 'GUILD_VOICE' });
                const t2vc = await newIHcat.createChannel("Team 2", { type: 'GUILD_VOICE' });
                const specvc = await newIHcat.createChannel("Spectators", { type: 'GUILD_VOICE' });

                let gamelogID = await Guilds.fetchGuildGamelog(interaction.guild.id);

                try
                {
                    const gamelogChannelExists = await interaction.guild.channels.fetch(gamelogID);
                }
                catch
                {
                    gamelogID = false;
                }
                
                // if no existing gamelog in DB or on discord, create in new IH category; else move existing one into new IH category
                if (!gamelogID)
                {
                    const b = await newInHouseCategory.createChannel("game-log", { type: 'GUILD_TEXT' });
                    b.setParent(newInHouseCategory);
                    gamelogID = b.id;
                }
                else 
                {
                    const gamelogchannel = await interaction.guild.channels.fetch(gamelogID);
                    await gamelogchannel.setParent(newIHcat);
                }

                return {
                    queue: qvc.id,
                    team1: t1vc.id,
                    team2: t2vc.id,
                    spectator: specvc.id,
                    gamelog: gamelogID,
                };
            };

            // object containing all inhouse channel IDs
            const gamechannels = await getGameChannels(newInHouseCategory);

            // update guild's data in DB for new channels to use for inhouse
            await Guilds.updateGuildInhouseIDs(interaction.guild.id, { ...gamechannels, category: newInHouseCategory.id },
            );

            // filter for button event listener on bot's sent message, only accept button interactions from command caller
            const filter = i =>
            {
                i.deferUpdate();
                return i.user.id === interaction.user.id;
            };

            const firstReply = await interaction.reply({ content: "Do you want to delete all old inhouse categories and their contained channels?\n*(Even if they aren't generated by the bot, any categories named 'Inhouse' will be deleted)*", components: [bEmbeds.ar.confirm], fetchReply: true, ephemeral: true });

            // wait for user response (y/n) to deleting old channels
            firstReply.awaitMessageComponent({ filter, componentType: 'BUTTON', time: bEmbeds.msToTimeout })
                .then(btnInteraction =>
                {
                    if (btnInteraction.customId === "yes")
                    {

                        // fetch all categories in server with name 'inhouse'
                        // would still select (and thus later delete) any category called 'inhouse' regardless of if it's for RL
                        // i will not be making a workaround for this
                        const oldInhouseCategories = interaction.guild.channels.cache.filter(channel => channel.name.toLowerCase() === "inhouse" && channel.id != newInHouseCategory.id);

                        // delete all categories
                        oldInhouseCategories.each(cat =>
                        {
                            cat.children.each(chan =>
                            {
                                if (chan.id == gamechannels.gamelog)
                                {
                                    chan.setParent(newInHouseCategory);
                                }
                                else
                                {
                                    chan.delete();
                                }
                            });
                            cat.delete();
                        });

                        interaction.editReply(bEmbeds.preset.success);

                    }
                    else
                    {   
                        interaction.editReply({ content: ":white_check_mark: Gamelog moved to new in-house category. (Old voice channels not deleted)", components: [] });
                    }
                })

                // put up error embed if error
                .catch(err => 
                {
                    console.log(err);
                    interaction.editReply(bEmbeds.preset.err);
                });
            break;
        }

        default:
            // there is no reason to ever get here
            return interaction.reply("???");
    }
}